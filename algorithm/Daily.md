# Daily



### 2020_12_28

1. BOJ_1463
   - 주의사항: 딱히 없음
2. BOJ_9251 (LCS)
   - 주의사항
     - 각각의 문자열에서 문자가 동시에 추가되는 상황으로 코드를 짜야한다



### 2020_12_29

1. BOJ_1003
   - 주의사항
     - 언제나 인덱스 조심



### 2020_12_30

1. BOJ_1756
   - 탐색은 이분탐색을 항상 염두해두자
   - loop로만 구현 => recursion으로 해보기
2. BOJ_10434
   - 에라토스테네스의 체
   - 딕셔너리의 in 연산은 O(1) => visited로 활용했음
   



### 2020_12_31

1. BOJ_2805
   - 이분탐색은 O(logN) 이므로 탐색중간에 for문이 있어도 N * log N으로 가능
2. BOJ_1654
   - BOJ_2805와 유사한 문제
   - 특정값이 아닌 이상, 이하를 찾는 경우 리턴할 변수를 따로 설정해놔야함



### 2021_01_01

1. BOJ_10815
   - 단순한 탐색 문제
   - 이진 탐색(1280ms)보다 딕셔너리(592ms)를 이용한 것이 더 빨랐음
     - in 연산은 BOJ_10434 활용한 것 처럼 O(1) => 해시맵
     - 이진 탐색과 딕셔너리를 언제 사용해야 하는지 생각해서 사용하기
2. BOJ_2110
   - 잘못된 항목을 binary search 해서 계속 틀림
   - binary search에서 시간적 여유가 생긴다 => 조금은 무식한 방법을 사용해도 된다
3. BOJ_1790
   - 이진탐색 카테고리 안에 있었지만 그냥 푸는게 나을거 같아서 품
   - 이진탐색으로 다시 풀어볼 것



### 2021_01_02

1. BOJ_1764
   - 단순히 값이 있냐 없냐인 문제 => 딕셔너리를 사용해봤으나 문제 없음
2. BOJ_2512
   - 나무자르기, 랜선자르기 문제와 같음
3. BOJ_1789
   - 이진 탐색은 단순히 탐색에 사용
   - 애드혹 느낌



### 2021_01_03

1. BOJ_3079
   - 이분탐색 단독 문제
   - BOJ_2100, 2805, 2100, 2512 문제와 거의 같음



### 2021_01_04

1. BOJ_2343
   - 시간을 binary search 로 log n으로 탐색
   - 그 시간에 대해서 가능성을 n으로 탐색
   - O(n log n)인 전형적인 문제
   - 주의점: 초기 탐색범위를 잘 설정해야 함 => 좌측범위를 0으로 해서 해맴



### 2021_01_05

1. BOJ_2776
   - 별다른 어려운점은 없었음
   - 다른사람의 코드를 보니 dictionary를 쓴 경우가 더 빨랐음
     BOJ_1754에서 썻던것 처럼 단순히 있다 없다 에서는 딕셔너리가 더 좋은 선택이 될수도 있음
   
2. BOJ_17070

   1. DFS로 풀이 했을때 시간초과가 남
      - 단순히 16 * 16으로 완탐을 해도 되겠다 생각 => O(n^2) 으로 생각
      - 하지만 dfs로 답을 낼경우 방문한 곳을 또 방문해야 하는 문제점이 생김
      - 다시 알고리즘을 살펴보니 각각의 점에서 최소 2가지의 선택지가 있음 => O(2^n)
   2. dp 로 접근
      - 어떤 한점에 도착하는 경우가 그 전에 계산된 결과에 좌우됨
      - 각각의 점을 한번만 방문하면 가능 => O(n^2)

   - dfs, bfs를 사용하기 전에 한번더 생각해보기
   - 이제 시간초과가 나는 경우 풀이법이 숙련되지 않아 나타나는 경우는 많이 없을것 같음 => 시간 초과가 발생하면 아예 처음부터 다시 생각해보기

3. BOJ_17471

   - 처음에 모든 경우를 다해야 하는지 고민
   - 고민하지 말고 n을 보고 바로 시간을 추정해보자



### 2021_01_06

1. BOJ_9095
   - 2개가 아닌 3개의 숫자로 하는 피보나치 문제
2. BOJ_1932
   - 별다른 어려운점 없었음
   - 알고리즘 분류에서 dp로 들어간거라 언제 dp로 풀지 결정하는 방법을 생각해야 할듯



### 2021_01_07

1. BOJ_14425

   1. trie를 dictionary로 구현
      - O(L * M)  L == 사전에 있는 가장 긴 단어, M == 찾을 단어수
      - 밑에 set을 이용한 방법보다 매우 느림
      - 하지만 정확한 단어 검색이 아닌 add?? 와 같은 경우도 검색가능하게 custom 가능함
   2. set을 이용
      - set, dictionary의 경우 in 연산이 O(1)이므로 속도가 빠름
        but, 정확히 일치하는 문자열만 검색가능
   3. trie를 class로 만들어 보기

2. BOJ_5052

   1. trie를 dictionary로 구현
      - 이문제의 경우 정확히 일치하는 것을 찾는것이 아니기 때문에 set 사용 불가
   2. class로 만들어 보자

   - 주의사항 
     - 중간에 break를 걸고 나갈 때 input을 다 받지 않은 상태로 함수가 끝나 오류가 발생
       (백준 : 런타임 에러 (NZEC))